{
  "slug": "Mes compétences techniques",
  "title": "Compétences techniques",
  "content": {
    "articles": [
      {
        "title": "Développer un site web",
        "customCss": {},
        "direction": "row",
        "banner": {
          "headline": "Développer un site web",
          "image": {
            "src": "/img/article-web.png",
            "alt": ""
          }
        },
        "elements": [
          {
            "type": "text",
            "content": "<p>Le développement de sites web est un domaine qui a gagné en popularité au fil des années, avec le nombre exponentiel de sites sur le web. En 2017, à l'âge de 17 ans, mon grand frère m'a suggéré de m'initier au web, alors que je n'avais jamais écrit la moindre ligne de code. J'ai commencé par apprendre le HTML pour construire des sites web, puis le CSS pour ajouter du style à ces derniers. Par la suite, j'ai plongé dans l'apprentissage des différents langages de programmation utilisés dans le web, tels que JavaScript, PHP et Java.</p>\n<p>Très rapidement, j'ai compris que le web serait le domaine dans lequel je voulais évoluer professionnellement, car sa popularité ne cessait de croître. Les frameworks tels que ReactJS et VueJS connaissaient une croissance importante (AngularJS étant en déclin à ce moment-là). À cette époque, la communauté de développeurs était en effervescence, se formant autour de différents langages. On observe encore aujourd’hui des communautés très soudées autour des différents langages de programmation, ce qui est selon moi une excellente chose, car si on est bloqué par un problème, on peut facilement trouver de l’aide grâce à ces communautés.</p>\n<p>Cependant, je voyais de nombreuses personnes spécialisées dans des technologies spécifiques. Mon objectif n'était pas de me spécialiser, mais plutôt d'apprendre des concepts et de m'améliorer en résolvant des problèmes. Je voulais devenir un véritable couteau suisse, un développeur polyvalent, capable de s'adapter à n'importe quelle technologie imposée en entreprise.</p><p>Lorsque je commençais à postuler pour la première fois à des centaines de candidatures de stage, j'ai réalisé à quel point la concurrence était rude. Le marché regorge de postes pour des développeurs maîtrisant une technologie spécifique. À mes yeux, il était crucial de se démarquer, car de nombreux développeurs concurrents se spécialisent dans des technologies précises, répondant ainsi à des demandes de postes précises. Or, si ces technologies étaient amenées à disparaître du jour au lendemain, que deviendraient ces développeurs ?</p><p>Ma stratégie a toujours été de savoir m'adapter sans nécessairement apprendre par cœur des technologies. C'est cette capacité d'adaptation qui, à mon sens, distingue un développeur expert en ReactJS, par exemple, d'un développeur polyvalent. Je recommande vivement à quiconque de suivre cette philosophie, car elle favorise une croissance rapide en tant que développeur au sein d'une entreprise.</p><p>Il est crucial de garder à l'esprit que le domaine de l'informatique évolue rapidement. Les technologies apparaissent et disparaissent à une vitesse fulgurante, remplacées par d'autres, créant ainsi une boucle constante. De plus, l'avènement de l'intelligence artificielle bouscule notre quotidien, avec des outils tels que ChatGPT capables de générer des scripts dans des langages spécifiques à votre place. La capacité à s'adapter et à rester polyvalent demeure une clé essentielle pour réussir dans le monde du développement web.</p>",
            "customCss": {
            }
          },
          {
            "title": "Quelques situations concrètes",
            "direction": "row",
            "elements": [
              {
                "type": "text",
                "sort": 1,
                "content": "Dans le cadre de mon alternance, j’ai eu l’occasion de travailler sur plusieurs projets web.-\t Un « CMS » permettant de générer des site web (Wordpress), destiné à une entreprise multinationale (business b2b). -\tUne plateforme web de comptabilité pour entreprises.-\tUne plateforme de crowdfunding immobilière développé par un ancien employé. Le code source étant assez vieux, j’ai eu à migrer une bonne partie de cette dernière afin de la rendre plus maintenable. Mon regard critique sur mon niveau d’expertiseLe domaine du web évolue constamment, et malgré mon apprentissage continue, j’ai encore tant de choses à apprendre. De plus, il est très facile d’écrire du code sale, mais concevoir un site web très bien structuré doté d’une architecture facilitant son maintien et son évolution, c’est tout un autre niveau d’expertise. Aujourd’hui, je ne me considère pas être un pur car cela demande énormément d’expérience. C’est ce qui va différencier le bon développeur du mauvais développeur lors des entretiens techniques.  D’ailleurs, il est assez facile d’identifier le bon développeur et le mauvais lors d’un entretien. Le bon développeur va plus loin qu’écrire du code. Il sait être créatif, va tenter d’imaginer les meilleures solutions, et se questionnera sur ses propres choix, tandis que le mauvais développeur va apporter une solution sans la questionner et la remettre en question. Enfin, un développeur se doit d’être doté d’une très bonne logique et être capable de résoudre des problèmes. Il existe deux catégories de développeurs aujourd’hui. Il y a les développeurs spécialisés dans une technologie spécifique, et les développeurs polyvalents. Mon objectif personnel est d’être un développeur polyvalent. J’aimerai pouvoir m’adapter dans n’importe quel environnement, peu importe les langages de programmation imposés et faire face à tout type de problème. Je travaille cela chaque jour, et selon moi ce serait à la fois une satisfaction et un accomplissement personnel.",
                "customCss": {
                }
              }
            ]
          }
        ]
      },
      {
        "title": "Définir une architecture adaptée pour un logiciel afin de le rendre stable, évoluable et maintenable.",
        "customCss": {},
        "direction": "row",
        "banner": {
          "headline": "Définir une architecture adaptée pour un logiciel afin de le rendre stable, évoluable et maintenable.",
          "image": {
            "src": "/img/article-archi-adaptee.jpg",
            "alt": ""
          }
        },
        "elements": [
          {
            "type": "text",
            "content": "<p>Dans le monde du développement logiciel, la compétence technique de définir une architecture backend adaptée joue un rôle essentiel dans la création de solutions logicielles durables. L'architecture backend est la fondation sur laquelle repose tout le système, déterminant sa stabilité, sa capacité à évoluer avec les besoins changeants et sa facilité de maintenance.</p><br><h2>La stabilité d'un logiciel</h2><p>La stabilité est cruciale pour tout logiciel en production. Une architecture backend bien conçue doit garantir la fiabilité du système en minimisant les temps d'arrêt, les bugs et les performances dégradées. Cela implique le choix judicieux des technologies, la mise en œuvre de bonnes pratiques de développement et la prise en compte des aspects liés à la sécurité. L'utilisation de frameworks robustes, la mise en place de tests automatisés approfondis et l'intégration continue sont des éléments clés pour assurer la stabilité du backend. La conception orientée microservices est un modèle architectural qui favorise la stabilité en décomposant l'application en composants indépendants, minimisant ainsi l'impact d'un échec sur l'ensemble du système. Pour donner un exemple concret, durant mes études à l’INTECH, il nous a été demandé, par groupe, de développer un site web de réservation de billets d’avion en ligne. Ce site web devait à minima afficher une liste de vols d’avions, une barre de recherche pour filtrer les vols, ainsi que permettre à l’utilisateur de faire des réservations. Pour procéder, nous avons commencé à développer la partie backend du site en suivant le modèle MVC pour pouvoir structurer la donnée, mettre en place des contrôleurs qui vont interagir avec ces données, et enfin envoyer la données au frontend. En suivant ce modèle, nous avons mis à disposition au frontend l’ensemble des endpoints API pour obtenir des vols d’avions et faire des réservations. Chaque vol d’avion était stocké dans une base de données MySQL. Néanmoins, il nous a été demandé de remettre en cause l’architecture du code de notre application et d'identifier le risque qui se présentait face à une telle architecture. Nous nous sommes rendus compte que notre application était exposée à un risque majeur : le downtime général. Ce que j’entend par “downtime général”, c’est que si jamais la machine hébergeant le code, venait à tomber en panne, alors l’entièreté du backend tomberait en panne. De plus, si une partie du code venait à comporter un bug, alors toute l’application serait compromise. C’est à ce moment qu’on a décidé d’introduire au sein de notre application une notion bien connue en 2023 : les microservices.</p><div class='blog-img-wrapper'><img class='blog-img' src='/img/microservices-vs-monolithic.png'></div><p>L’architecture microservices consiste à découper notre application en plusieurs petits services, chaque service ayant une seule et unique responsabilité au sein de notre programme. Chaque service tourne indépendamment comme serveurs individuels, dont le code peut tourner sur une seule machine ou sur plusieurs machines différentes. L’application pourra alors interagir avec ces services via des requêtes HTTP. Si un seul service devait tomber en panne, alors cela n'impactent pas les autres dans la mesure où chaque service est isolé. De ce fait, pour notre application, nous l’avons découpé de la manière suivante :</p><div class='blog-img-wrapper'><img class='blog-img' src='/img/schema-architecture-app.png'></div><p>Notre application est désormais constitué de 3 services : </p><ul><li>Un moteur de réservation de vols</li><li>Un service qui retourne des vols d’avions</li><li>Une service agissant comme interface pouvant interagir directement avec la base de donnée</li></ul><p>Si le moteur de réservation venait à tomber en panne, cela n'empêchera pas les utilisateurs de consulter les vols d’avions sur le site. Néanmoins, ils devront être prévenus qu’il n’est pas possible de réserver des avions. Si la base de données tombait, alors le service d’exposition de vols pourrait quand même afficher des vols d’avions grâce à un système de cache qui garde en mémoire des vols d’avions et qui se rafraîchit si les informations de vols venaient à être mis à jour. En conclusion, nous venons de concevoir un système faiblement couplé où chaque service peut fonctionner de manière indépendante sans que l’interruption de l’un, fasse le malheur des autres.</p><br><h2>Scalabilité verticale et horizontale</h2><p>Dans le développement de notre site de réservation de billets d'avion à l'INTECH, l'introduction de l'architecture microservices a été une étape cruciale pour améliorer la stabilité et la pérennité de notre application. Cependant, notre démarche ne s'est pas limitée à une simple répartition des responsabilités entre différents services. Elle a également jeté les bases pour une scalabilité tant verticale qu'horizontale, des éléments essentiels pour anticiper la croissance future et garantir une expérience utilisateur sans faille.</p><br><h3>Scalabilité verticale</h3><p>La scalabilité verticale, ou \"upscaling\", consiste à augmenter la capacité d'une ressource existante, généralement en renforçant la puissance d'une machine serveur. Dans notre cas, chaque service individuel au sein de notre architecture microservices peut être adapté indépendamment en fonction de ses besoins spécifiques. Par exemple, si le moteur de réservation de vols commence à subir une charge importante, nous pouvons augmenter la puissance de la machine hébergeant ce service particulier. De même, si le service de retour des vols d'avions nécessite plus de ressources, il peut être ajusté de manière isolée. Cette flexibilité verticale nous permet d'optimiser chaque composant du système en fonction de ses besoins spécifiques, contribuant ainsi à une utilisation plus efficace des ressources et à une réponse adaptative aux variations de la demande.</p><br><h3>Scalabilité horizontale</h3><p>La scalabilité horizontale, ou \"outscaling\", va au-delà de l'adaptation des ressources existantes en ajoutant simplement de nouvelles instances du même service. Dans notre architecture microservices, chaque service peut être répliqué sur plusieurs machines distinctes, permettant une distribution équilibrée de la charge. Prenons l'exemple du service qui retourne des vols d'avions. Si la demande augmente de manière significative, plutôt que de renforcer une seule instance de ce service, nous pouvons déployer plusieurs copies de ce service sur différentes machines. Cela garantit une répartition égale de la charge, évitant les goulots d'étranglement et assurant une réponse rapide aux requêtes des utilisateurs.</p><br><h2>Lien entre la stabilité et la pérennité</h2>En adoptant une approche combinée de scalabilité verticale et horizontale au sein de notre architecture microservices, nous renforçons non seulement la capacité de notre application à gérer des charges variables, mais nous nous protégeons également contre les pannes potentielles. En cas de pic de trafic, la scalabilité horizontale permet à notre application de s'étendre de manière transparente, garantissant une expérience utilisateur fluide. De plus, la scalabilité verticale nous offre la possibilité d'ajuster finement les ressources pour répondre aux besoins spécifiques de chaque service, optimisant ainsi les performances globales.</p><p><h2>Conclusion</h2><p>Pour conclure, j'aimerais mettre l'accent sur l'importance de bien réaliser un schéma d'architecture d'une application en amont avant de se jeter dans le grand bain. En effet, en identifiant les différents composants au sein de notre application, on arrive mieux à prévoir les problèmes qu'on pourrait rencontrer. De plus, on a une meilleure vision sur le projet et on peut anticiper plus rapidement des implémentations de solutions complexes à des problèmes. Par exemple, dans le cadre d'un projet comme un site web de réservation de billets d'avion, en schématisant notre application et le découpant en plusieurs services, on peut constater plus rapidement des problématiques concernant la scalabilité horizontale et verticale.</p>",
            "customCss": {
            }
          }
        ]
      },
      {
        "title": "Implémenter un logiciel de qualité, en choisissant des structures de données adaptées et des algorithmes pertinents afin d’assurer la robustesse du logiciel.",
        "customCss": {},
        "direction": "row",
        "banner": {
          "headline": "Implémenter un logiciel de qualité, en choisissant des structures de données adaptées et des algorithmes pertinents afin d’assurer la robustesse du logiciel.",
          "image": {
            "src": "/img/article-devlogiciel.jpg",
            "alt": ""
          }
        },
        "elements": [
          {
            "type": "text",
            "content": "<p>Lorsque l'on développe un logiciel, il est essentiel de veiller à ce qu'il soit de qualité, robuste et fiable. Pour ce faire, l'implémentation du logiciel doit être effectuée en choisissant des structures de données adaptées et des algorithmes pertinents. Cette compétence est cruciale pour garantir que le logiciel fonctionne correctement, qu'il est performant et qu'il peut répondre aux besoins des utilisateurs.</p><h1>Qu’est ce qu’une structure de donnée ?</h1><p>Une structure de donnée est une manière de stocker une information dans la mémoire vive d’un ordinateur dans l’objectif de la traiter plus facilement. Il existe plusieurs structures de données. </p><h2>Les tableaux</h2><p>Le tableau est la structure de donnée la plus courante, et est enseigné dans toutes les écoles pour les débutants. Dans un tableau, chaque élément est indexé, c’est-à-dire qu’on affecte à chaque donnée un numéro permettant au programme d’y accéder. Ensuite, chaque élément est placé de façon contiguë dans la mémoire.<div class='blog-img-wrapper'><img class='blog-img' src='/img/tableau_standard.png'/></div></p><h2>La liste chaînée</h2><p>Une liste chainée est une structure de donnée permettant de stocker des données de façon linéaire, tout comme le tableau. Une liste est composée de plusieurs nœud. Chaque nœud stocke une information particulière (un entier, une chaine de caractère etc…), ainsi qu’un lien vers un autre nœud.<div class='blog-img-wrapper'><img class='blog-img' src='/img/liste_chainee.png'></div> Il y a plusieurs différences entre un tableau et une liste chainée. Dans un tableau, on ne peut stocker qu’un seul type de donnée. Par exemple, si l’on souhaite ajouter une nouvelle donnée dans un tableau stockant que des entiers, notre donnée devra obligatoirement être un entier. Dans une liste chainée, on peut stocker tout type de données (des entiers, des nombres flottants, des chaines de caractères, des listes, des tableaux etc…).<br>De plus, dans un tableau traditionnel, chaque élément est stocké côté à côté en mémoire, tandis que dans une liste chainée, chaque élément est stocké à des endroits libres, sélectionnés par le système d’exploitation.</p><div class='blog-img-wrapper'><img class='blog-img' src='/img/representation_liste_chainee.png'><i>Representation d'une liste chainée en mémoire</i></div><br><br><div class='blog-img-wrapper'><img class='blog-img' src='/img/representation_tableau.jpg'><i>Representation d'un array (tableau) en mémoire</i></div><br><p>De plus, il est plus simple d’effectuer des opérations d’insertion et de suppression d’élément dans une liste chainée. Pour supprimer un élément “A” dans une liste, il suffit de parcourir la liste à partir de la tête de liste jusqu’à tomber sur l’élément précédant “A”, puis remplacer le lien partant de l’élément précédant A vers A par un lien vers l’élément situé après A. <br>Dans un tableau traditionnel, une fois l’élément supprimé on doit décaler tous les éléments le suivant, vers la gauche pour combler le trou crée par la suppression, ce qui demande du travail supplémentaire pour l’ordinateur.</p><h1>Comment mesure-t-on l’efficacité d’un programme informatique ?</h1><p>Un informaticien sera constamment amené à se poser des questions sur l’efficacité de son programme informatique. On pourrait dire que l’efficacité d’un programme informatique se mesure en observant le temps qu’il met à arriver à terme de son exécution. Cependant, cette hypothese est biaisé.<br>Prenons un exemple concret. <br>Bob, un élève étudiant en 1ere école d’ingénieur, a pour exercice d’écrire deux programmes informatique distinct, A et B, qui doivent trier dans l’ordre croissant un tableau traditionnel contenant 10 nombres entiers. Bob doit utiliser deux approches différentes pour trier un tableau d’entiers, d’où le besoin d’écrire deux programmes séparés.<br>A et B trient leur tableau en suivant un algorithme particulier. On part du principe que l’algorithme qu’A va suivre est théoriquement jugé comme moins efficace que l’algorithme que B suit. <br>Bob veut s’assurer que le programme A sera plus lent que le programme B. <br> Bob utilise un chronomètre et effectue plusieurs experimentations. Il constate qu’à certains essais, A prend plus de temps que B, et dans d’autres cas, B prend plus de temps. Bob ne comprend pas...<br>En effet, il n’est pas viable de mesurer l’efficacité d’un programme informatique à partir du temps qu’il a pris pour arriver à terme, car il y a beaucoup de facteurs qui entrent en compte et viennent biaiser les résultats comme : <br>Les performances du processeur<br>Les échanges chimiques et thermiques se produisant au niveau des circuits electrique qui viennent créer des perturbations<br>Et bien d’autres.. <br>Pour cela, il n’est pas judicieux de mesurer l’efficacité d’un programme informatique par la temps qu'il prend, mais plutôt en quantité d’opération qu’il va effectuer pendant tout le cycle de vie de ce dernier.<br>Pour résumer toute cette partie, lorsqu'on parle de structures de données adaptées, cela signifie que le choix des structures de données doit être effectué en fonction des besoins du logiciel. De plus, ce choix doit être fait en prenant en compte la quantité des données, ainsi que la variation de la quantité de donné qu’on va stocker, si cette quantité est amené à augmenter au fil du temps ou non.</p><h1>Le choix des algorithmes</h1><p>De même, le choix des algorithmes est tout aussi important. Les algorithmes pertinents doivent être choisis pour garantir que le logiciel fonctionne correctement, qu'il est rapide et efficace. <br>Il est également important de veiller à la robustesse du logiciel. Cela signifie qu'il doit être capable de gérer les erreurs et les exceptions de manière appropriée, de sorte qu'il puisse continuer à fonctionner même en cas d'erreurs ou de pannes. Pour cela, des techniques de gestion des erreurs et de gestion des exceptions doivent être mises en place.<br>En fin de compte, l'implémentation d'un logiciel de qualité nécessite de choisir des structures de données adaptées et des algorithmes pertinents pour garantir la robustesse du logiciel. Cela permet de garantir que le logiciel fonctionne correctement, qu'il est performant et qu'il peut répondre aux besoins des utilisateurs. La compétence pour implémenter un tel logiciel est donc essentielle pour tout développeur de logiciel.</p>",
            "customCss": {
            }
          }
        ]
      }
    ]
  }
}