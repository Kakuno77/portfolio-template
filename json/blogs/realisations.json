{
  "slug": "realisations",
  "title": "Mes réalisations",
  "content": {
      "articles": [
          {
              "banner": {
                  "headline": "lorem ipsum dolor amet",
                  "image": {
                      "src": "https://miro.medium.com/v2/resize:fit:1400/1*SOhDdB1GYP_scqZTXoWC2g.png",
                      "alt": ""
                  }
              },
              "title": "Kuberneteche",
              "customCss": {},
              "direction": "row",
              "elements": [
                  {
                      "type": "text",
                      "sort": 2,
                      "content": "Kuberneteche, un orchestrateur de conteneurs Docke)IntroductionAujourd’hui, les entreprises informatiques sont régies par une multitude de machines déployées en environnement de production, présents pour répondre aux besoin des clients. En tant que client, on attend du prestataire qu’il livre un produit qui répond à nos besoins. Cependant, le client n’imagine pas l’infrastructure qui a été mis en place pour à la fois développer le produit, et le déployer en production. En réalité, un site web est composé de plusieurs entités, chacun nécessitant d’être hébergé et maintenu. Pour un site web classique, on retrouve : Le code source du « frontend »Le code source du « backend »Une base de donnéesPour un seul produit, on doit administrer trois entités. Et encore, on pourrait penser que déployer ces trois entités une seule fois sur un ordinateur, suffit. Cependant, plusieurs évènements exceptionnels peuvent se produire durant tout le cycle de vie du produit.On peut rencontrer des interruptions. Le site web peut arrêter de fonctionner si : la machine l’hébergeant, tombe en panneun problème de réseau survient dans le réseau où la machine est connectéLa machine est trop sollicitée en termes de mémoire vive, de calculs effectués par le processeur, et/ou de charge réseau (trop de requêtes http pouvant inonder la machine)Il est donc nécessaire d’avoir un réel suivi de l’infrastructure, en mettant en place des dispositifs automatisés permettant de remettre en place la machine si elle rencontre un problème, des sauvegardes de la base de données pour éviter des pertes de données, et bien d’autres. Parfois, on doit augmenter les ressources de la machine, déplacer le produit sur une autre machine, créer plusieurs répliques du site web etc…Faire tout cela manuellement peut - être fatiguant, et l’erreur est humaine. Il suffit que l’administrateur commette une erreur d’inattention, et cela peut couter cher au client.On pourrait imaginer une solution informatique pouvant automatiser tout le processus d’administration de plusieurs machines connectées à un même réseau. C’est là qu’intervient mon projet Kuberneteche !Contexte1.a. Qu’est - ce qu’un conteneur docker1.b. Qu’est - ce qu’on utilisait avant les conteneurs (parler de l’architectures à base de VM, puis comparer avec les conteneurs)1.c. Présentation du projet ainsi que des objectifs, et des besoins auxquels il devra répondre1.d. les produits existants sur le marché (Kubernetes, docker swarm, docker compose, quelques solutions maisons qui ont fait faillite)1.e. Kubernetes, le leader du marché, et pourquoi c’est le leaderFonctionnement2.a. technologies utilisés (langage GO, scripting bash, creations de sous - réseaux)     2.b. les fonctionnalités (healthchecking, répartition de la charge entre les différentes machines du cluster, etc…)Les étapesÉcriture des différents fichiers scripts pour la création d’un cluster, des machinesÉcriture de deux serveurs web en langage Go, un premier serveur qui va traiter les demandes du propriétaire du cluster, (demandes pouvant être par exemple le déploiement d’un programme sur une machine du cluster, ou l’ajout d’une machine sur le cluster pour augmenter les ressources)Mise en place de l’healthcheckingImplémentation d’un algorithme de load balancing (répartition de charge)3) Durée de réalisation (5 à 6 mois)Difficultés rencontrés / challenge à releverRésultat Mon regard critique",
                      "customCss": {}
                  }
              ]
          },
          {
              "banner": {
                  "headline": "lorem ipsum dolor amet",
                  "image": {
                      "src": "/img/pcr.jpg",
                      "alt": ""
                  }
              },
              "title": "Développement en entreprise d’une plateforme administrative pour centre de dépistage PCR",
              "customCss": {},
              "direction": "row",
              "elements": [
                  {
                      "type": "text",
                      "sort": 2,
                      "content": "En pleine période de Covid, les administrations pharmaceutiques ont besoin de saisir les formulaires des personnes se faisant dépister du covid - 19 via tests PCR. Certaines d’entre elles ne peuvent pas gérer manuellement les entrées administratives en raison d’une augmentation conséquente des personnes malades. Pour cela, le laboratoire Clément a sollicité l’entreprise afin d’avoir en sa possession un outil en ligne pouvant simplifier l’entrée des formulaires. Cet outil consiste en une plateforme en ligne permettant d’entrer les informations via un formulaire PCR généré automatiquement par la plateforme. Normalement, le patient remplissait un fichier PDF, puis l’envoyait au centre de dépistage. Ensuite, le centre de dépistage rentrait les informations manuellement dans leur logiciel nommé « Concerto ». L’objectif est d’enlever cette dernière étape en permettant au patient d’entrer directement son formulaire sur une plateforme qui sera développé par notre entreprise. Le formulaire enregistré sur notre plateforme, sera transmis automatiquement au centre de dépistage, dans leur logiciel « Concerto ».L’arrivé d’un nouveau client présente un enjeu financier et de visibilité pour l’entreprise.Un tel projet peut engranger une grosse entrée d’argent dans l’entreprise, d’autant plus « grâce » à la période de crise du Covid - 19 qui génère une grande demande sur le marché pharmaceutique. De plus, ce projet pourrait donner une certaine visibilité à XO7, pouvant attirer davantage de clients provenant de tout secteur confondu.J’ai eu l’opportunité de participer au développement de la plateforme en ligne permettant de lister les formulaires saisis, à la mise en place du formulaire destiné au patient (ce dernier étant généré après que le patient ait scanné un QR code) ainsi que la transmission de ce dernier vers le logiciel « Concerto » du laboratoire concerné.Dans le cadre de ce projet, j’ai collaboré avec une petite équipe de développeurs frontend et backend et avec une cheffe de projet interne à notre entreprise, qui gérait la communication et le recueil des besoins auprès du directeur des laboratoires Clément.A l’issue de ce projet, les laboratoires Clément ont gagné en efficacité grâce à notre système, car désormais, ils n’ont plus besoin d’entrer les formulaires PCR manuellement.Ce projet a pu m’apporter une nouvelle expérience, de nouvelles connaissances techniques et une montée en compétences non - négligeables.Cependant, ce projet comportait des risques :  - \tL’entreprise pourrait ne pas tenir les délais de livraison - \tLe client pourrait trouver un prestataire remplaçant - \tLes pannes sur la plateforme en cours de développement, pourraient causer des problèmes administratifs et rendre les clients de la plateforme mécontents.Depuis la fin de la crise sanitaire, en raison de la baisse du nombre de cas lié à la COVID - 19, la demande a chuté, ce qui laisse notre projet dans un état « inactif ».Cette réalisation m’a aidé à progresser dans le sens où j’ai développé une capacité à m’adapter face à différents clients, comprendre les enjeux et besoins du projet, une capacité à travailler sous pression dans des délais serrés.",
                      "customCss": {}
                  }
              ]
          },
          {
              "banner": {
                  "headline": "lorem ipsum dolor amet",
                  "image": {
                      "src": "/img/compiler.png",
                      "alt": ""
                  }
              },
              "title": "Développement d'un compilateur source à source",
              "customCss": {},
              "direction": "row",
              "elements": [
                  {
                      "type": "text",
                      "sort": 3,
                      "content": "Durant mon cursus de développeur à L’ESIEA, j’ai eu l’occasion de développer un compilateur “Code maison” vers le langage Javascript. Pour ma part, je suis un grand passionné par l'étude des algorithmes ainsi que l’utilisation de diverses structures de données. Ainsi, ce projet m’a permis de comprendre et utiliser les arbres syntaxiques, qu’on verra plus en détail ci-dessous.\t<h1>1) Qu’est ce qu’un compilateur  source à source</h1><p>Un compilateur source à source est un programme qui va convertir un programme écrit dans un langage A, vers un langage B. L’exemple le plus connu aujourd’hui étant Babel JS, un compilateur qui sait convertir du code Javascript d’une certaine version vers un code Javascript d’une version antérieure, permettant d’assurer la rétrocompatibilité sur des moteurs javascripts plus anciens.Un compilateur suit des étapes précises</p>\t<h2>a) L’analyse lexicale</h2><p>Pour chaque instruction, le compilateur identifie chaque lexème (mot) de l’instruction. exemple : <div class='blog-img-wrapper'><img class='blog-img' src='/img/ex_langage_naturel.jpg'></div> Ci-dessus, on identifie chaque lexème (mot) de la phrase “Pierre aime-t-il ( un peu ) les pommes ?” en leur attribuant une nature (une classification, ex : adverbe).</p>\t<h2>b) L’analyse syntaxique</h2>\t<p>L’analyse syntaxique se base sur la forme des instructions.Autrement dit, il faut que chaque lexème présent dans chaque instruction soit placé dans un ordre qui lui donne du sens. En reprenant l’exemple de la phrase “Pierre aime-t-il ( un peu ) les pommes ?”,  ca ne ferait pas sens si on plaçait un autre lexème que “Pierre” en début de phrase (sans rajouter de majuscule pour compenser l’incohérence, on inverse seulement l’ordre de deux mots), comme “aime” par exemple, car toute phrase commence par une majuscule et se termine par un point, ce qui donnerait “aime Pierre -t-il (un peu) les pommes ?”...</p>\t<h2>c) L’analyse sémantique</h2><p>L’analyse sémantique est complémentaire à l’analyse syntaxique, et se base elle sur le fond des instructions. Dans cette étape, on vérifie si les lexèmes ont un sens dans leur contexte. Pour prendre un exemple réel, dans notre code maison on aura affaire à des déclarations de variables. Les variables peuvent avoir plusieurs types (entier, chaîne de caractères, booléens etc…)L’expression “entier A = 5” fait sens car on déclare une variable “A” de type entier, et on lui stock la valeur 5, qui est bien un entier. L’expression “entier A = 5+9-2” est également bonne car on fait une opération d’addition ainsi qu’une opération de soustractions sur des entiers, et seulement des entiers. Cependant, l’instruction “entier A = bonjour’” est sémantiquement incorrecte, bien qu’elle soit syntaxiquement correcte. En effet, on déclare une variable de type entier mais on lui affecte une chaîne de caractère. Il y a ici incohérence des types et donc erreur !Autre exemple, l’instruction: “entier A = 5 + ‘bonjour’” est sémantiquement incorrecte car on additionne un entier à une chaîne de caractère, qu’on stocke ensuite dans une variable de type entier. Pour prendre un exemple un peu plus compliqué, l’instruction: “chaine A = 5 + ‘bonjour’” pourrait être jugé comme fausse par notre compilateur, bien que ce genre d’instruction est toléré dans beaucoup de langage de programmation aujourd’hui, car ici on additionne un entier à une chaine de caractere et on l’assigne à une variable de type “chaine”. Dans la majorité des langages de programmation existants, on appelle celà de la concaténation de chaines de caracteres., c’est à dire qu’on vient ajouter au début de  la chaine de caractère “bonjour”, l’entier 5, qui se retrouve automatiquement “converti” en caractère par le compilateur. Notre variable “A” contiendra donc la chaine de caractère “5bonjour”, ce qui est valide sémantiquement parlant.Pour finir, on va revenir sur l’exemple de la phrase concernant Pierre. En plein milieu de la phrase “Pierre aime t-il (un peu) les pommes”, nous pouvons constater un groupe de mot “(un peu)” très suspicieux. En effet, syntaxiquement il n y a pas de problème à insérer une parenthèse ouvrante et fermante ainsi que plusieurs mots entre ces parenthèses, néanmoins on comprend rapidement que sémantiquement parlant il y a un problème car cela ne fait pas sens de dire “(un peu)” en plein milieu de cette phrase particulièrement. Il faut bien distinguer syntaxe et sémantique. Dans la sémantique on s'intéresse vraiment au sens profond de chaque lexème par rapport aux autres lexèmes tandis que dans la syntaxe on observe simplement l'ordre des lexèmes et la grammaire.</p>\t<h1>2) Quelques fonctionnalités développés</h1><p>Un programme est un ensemble d’instructions destinées à être exécutées une par une par le processeur. Dans les langages de programmation, chaque instruction a une syntaxe spécifique. Voilà quelques exemples dans le langage Javascript: <li>pour déclarer une variable “A” contenant la valeur 45: let A = 45</li><li>Pour effectuer une addition et stocker son résultat dans une variable “B”: let B = 5 + 9</li><li>ecrire une condition si, sinonsi, sinon: if (a == b){ … } else if {} else {}</li><li>Ecrire une boucle itérative: for (let i = 0; i &#60; 10; i++) {...}</li>Bien évidemment, pour développer un compilateur il faut bien fixer des règles syntaxiques précises, chose que j’ai faite avant de commencer le travail.On verra rapidement les règles que j’ai fixées pour mon “code maison”.Sans trop tarder, voici quelques fonctionnalités prises en compte pour ce compilateur: <h3>Analyse lexicale/syntaxique :</h3><li>opérateurs binaire</li> <li>appel de fonction</li><li>opérateur binaire (+, -, &#62;=, &#62;, &#60;, &#60;=, ==, *, \/, ET, OU)</li><li>définition de fonction (fonction mafonction (entier a) : entier { } )</li><li>déclaration de variable / initialisation (entier a; entier b = 1;)</li><li>affectation (b = 2)</li><li>branchement (si / sinon si / sinon)</li><li>boucle (tantque () { })</li><li>retourner</li><li>variable de type entier SEULEMENT</li> <h3>Analyse sémantique :</h3><li>Vérification des variables (declaration/redeclaration) dans les boucles, conditions, fonctions et appels de fonctions.</li><li>Vérification des fonctions (declaration/appel)</li></p><h1>3) Technologies utilisées</h1></h2><p>J’ai développé ce compilateur en langage C, langage bas niveau privilégié pour ses  bonnes performances, notamment dans les projets d'électronique embarqué. Pour compiler le code écrit en C, j’ai utilisé le compilateur bien connu “GCC”. De plus, j'ai utilisé l’outil populaire “Make” qui permet de produire des exécutables à partir de fichiers sources. Cet outil est très pratique lorsque notre programme comporte de nombreux fichiers sources. Dans ce cas, sans Make on devrait écrire en entier une longue ligne de commande pour compiler chaque fichier. C’est là que Make intervient car on a juste à lui fournir des règles, chaque règle étant associée à une ligne de commande. De ce fait, en moins de 10 secondes on peut compiler un logiciel et le rendre exécutable.</p>\t<h1>4) Les arbres syntaxique</h1><p>On en vient au fameux sujet qui m’a motivé à mener à terme ce projet jusqu’au bout : les arbres syntaxiques.Comment notre compilateur va t-il procéder pour convertir du code maison en javascript ? L’idée globale est que le compilateur parcourt de haut en bas chaque ligne de code.On appelle ce procédé le “Parsing”. Durant tout le processus de parsing, il va alors construire une liste chainée, et pour chaque ligne de code, il va créer un “noeud”. Un nœud comporte une racine, et des feuilles. La racine représente la nature de notre expression (ligne de code pour faire plus simple) tandis que les feuilles vont décrire en détail l’expression. <div class='blog-img-wrapper'><img class='blog-img' src='/img/noeud_ast.jpg'><i>un noeud de notre arbre</i></div></br>Par exemple, ci-dessus vous avez un nœud décrivant une opération, plus précisément une addition. En partant de la gauche vers la droite, on lit “5+4”.Au fur et à mesure qu’on va parser le code maison, on construit un nœud pour chaque instruction.A la fin on se retrouve avec un arbre complet. Une fois cet arbre complet, on a juste à le parser (parcourir) de haut en bas pour ainsi générer le code Javascript.A noter que durant cette étape, on est à l'étape de l’analyse lexicale + syntaxique. En effet, on effectue l’analyse lexicale ET syntaxique en simultané pour chaque instruction.Une fois toute cette étape terminée et notre arbre syntaxique entièrement généré, on peut passer à l’analyse sémantique. Dans l’analyse sémantique d’un langage de programmation, et dans le cadre de mon projet, on va seulement vérifier la cohérence des types (comme évoqué plus loin au-dessus).</p> <h1>5) Génération du code Javascript</h1><p>Félicitations, nous avons notre arbre syntaxique qui a été analysé syntaxiquement et sémantiquement. A présent on peut générer le code javascript. Cette étape est la plus simple et la plus rapide. On parcourt notre arbre et pour chaque nœud dans l’arbre, on génère le code javascript suivant. <div class='blog-img-wrapper'><img class='blog-img' src='/img/ex_ast.jpg'><i>Exemple d’un arbre syntaxique généré depuis un code maison, qui sera utilisé pour générer du code assembleur bas niveau</i></div></br>Le code source de ce projet est disponible à l’adresse <a href='https://github.com/rathesh77/CCompiler'>https://github.com/rathesh77/CCompiler</a> sur un repo github public qui peut être forké et utilisé à bon escient par n’importe qui.</p>",
                      "customCss": {}
                  }
              ]
          }
      ]
  }
}