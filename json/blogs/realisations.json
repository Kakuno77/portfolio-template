{
  "slug": "realisations",
  "title": "Mes réalisations",
  "content": {
      "articles": [
          {
              "banner": {
                  "headline": "lorem ipsum dolor amet",
                  "image": {
                      "src": "/img/article-twitter.jpg",
                      "alt": ""
                  }
              },
              "title": "Twitteche, un clone de X",
              "customCss": {},
              "direction": "row",
              "elements": [
                  {
                      "type": "text",
                      "sort": 2,
                      "content": "À travers le projet Twitteche, j'ai entrepris seul la réalisation d'un site web complexe :  un clone de X. J'ai décidé de lancer ce projet pour m'amuser, mais egalement pour mettre à profit toutes les competences que j'ai pu developpé jusqu'aujourd'hui. De plus, Twitter ayant été récemment racheté par Elon Musk, j'ai pensé que ce serait une experience attractive et drôle de reproduire ce site, qui est utilisé dans le monde entier.  <br>L'objectif derrière ce projet repose sur l'intégration des fonctionnalités de bases presents sur Twitter, c’est-à-dire :</br></br> <li>tweeter</li><li>retweeter</li><li>répondre sous un tweet</li><li>liker un tweet</li><li>suivre / ne plus suivre un utilisateur </li><li>envoyer des messages privés à un ou plusieurs utilisateurs</li></p><h2>Mon epopée</h2><p>Le développement de ce site était un challenge excitant, bien que j'ai fais face à quelques difficultés. J'ai dû m'occuper d'écrire du code sur toute la stack (backend et frontend). D'un côté, il aura fallu écrire le code frontend qui sera envoyé au navigateur, code en ReactJS. L'avantage de ReactJS est qu'il est facile de découper notre frontend en plusieurs composants réutilisables. De plus, ReactJS permet d'entretenir un état pour chaque composant. En effet, chaque composant React possède un état donc plusieurs propriétés qui peuvent être transférées des composants parents aux composants enfants. Il faut imaginer le frontend comme un ensemble de modules qui font des requêtes au backend, puis affiche les informations renvoyées par le backend, à l'utilisateur. Concernant le backend, j'ai dû écrire tous les points d'entrées (endpoints en anglais) qui vont servir au frontend pour requêter des informations. Cela peut être des informations sur un utilisateur, la liste des tweets écrits par un utilisateur, etc.</p><p>Le backend est le plus difficile à développer, car il s'agit du cœur de notre application. Sans lui, notre site web ne peut pas être dynamique. De plus, ce qui a été fastidieux, c'est de mettre en place une architecture qui permet un maximum de maintenir et faire évoluer le code le plus facilement possible sur le long terme. Néanmoins, j'ai pu arriver à une version stable du site en y allant à tâtons dans le développement. Je recommande fortement d'établir la liste des fonctionnalités, en faisant un ou plusieurs schémas d'architecture de l'application et finalement établir en avance les schémas des tables en base de données, car ces derniers aident à avoir une vision claire des entités et des liaisons entre ces derniers.</p><p>Dans l'ensemble, la plupart des fonctionnalités ne m'ont pas posé à l'exception d'une seule : intégrer la possibilité de faire des appels audio et vidéo avec plusieurs utilisateurs. En effet, J'ai dû me documenter sur l'API WebRTC afin d'en faire une implémentation. Cette API permet d'établir une connexion bidirectionnelle entre deux utilisateurs ou plus. De ce fait, via cette connexion, les utilisateurs peuvent s'échanger un flux audio (microphone) et vidéo (webcam). Je vais passer désormais à la description technique du projet en expliquant mes choix de technologies, ainsi que le fonctionnement de l'architecture CLEAN qui m'a été d'une grande aide. Avant tout, voici quelques aperçus du site.<div class='blog-img-wrapper' style='display:flex; max-width:800px; overflow-x: auto;'> <img class='blog-img' src='/img/twitteche1.png'/><img class='blog-img' src='/img/twitteche2.png'/><img class='blog-img' src='/img/twitteche3.png'/><img class='blog-img' src='/img/twitteche4.png'/></div></img></p><h2>Composition technique</h2><p>L'application se compose d'un frontend développé avec la bibliothèque <b>ReactJS</b>, d’un backend <b>NodeJS</b> écrit en <b>TypeScript</b>. Cette combinaison m'a permis de bénéficier de la flexibilité de <b>NodeJS</b> tout en ajoutant une couche de typage, réduisant ainsi les risques de bugs silencieux.\nJ’ai opté pour une base de données orientée graphe <b>Neo4J</b> afin de modéliser les relations complexes entre les utilisateurs, les tweets et d'autres entités du réseau social. De plus, une base de données <b>SQLite</b> a été intégrée spécifiquement pour stocker de manière sécurisée les messages privés des utilisateurs.</p><h2>Neo4J, Une base de donnée orientée graphe</h2><p>Le choix d’une base de données orientée graphe m’a paru naturellement comme étant la solution naturelle pour ce genre de projet. En effet, dans le cadre de notre application Twitteche, lorsqu’un utilisateur suit un autre utilisateur “Bob”, on souhaite que sur sa timeline principale s’affichent les tweets de Bob. De plus, on veut pouvoir suggérer à l’utilisateur quelques tweets écrits par les personnes suivies par Bob.\nNotre base de données doit pouvoir nous retourner ces résultats, et bien que de telles requêtes puissent être effectuées sur des bases de données relationnelles comme <b>MySQL</b>, <b>PostgreSQL</b> ou autre, on pourrait rencontrer des problèmes de performances. <b>Neo4j</b> stocke nos données sous forme de nœud connectés par des liens, ce qui rend la visualisation de ces mêmes données plus claire. De plus, Il est plus facile de modéliser ce genre de schéma sous forme d’un graphe et Neo4j a l’avantage de répondre à cette demande car il implémente des algorithmes d’insertion et de recherche dans des graphes.<div class='blog-img-wrapper'><img class='blog-img' src='/img/neo4jgraph.png' /><i>Un graphe <b>Neo4j</b>  décrivant des relations entre amis</i></div></p><h2>La <b>Clean architecture</b></h2><p>Durant le développement du backend, j'ai choisi de suivre la philosophie de la <b>Clean architecture</b>. Cette approche, popularisée par Robert C. Martin, vise à structurer le code de manière à rendre le système indépendant de tout framework ou technologie externe.\n\nLa <b>Clean architecture</b> divise le code en différentes <b>couches</b>, chaque couche ayant une responsabilité bien définie. La logique métier est isolée dans le cœur de l'application, rendant le code plus testable et flexible aux changements. Les détails d'implémentation spécifiques, tels que les frameworks ou les bases de données, sont relégués aux couches externes, permettant une évolutivité et une maintenance plus aisées.<div style='max-width:300px' class='blog-img-wrapper'><img class='blog-img' src='/img/clean-arch.png'/><i>Les couches de notre <b>architecture Clean</b></i></div><p>Il existe 4 couches : <ol><li>La couche “<b>entité</b>” représente les entités de notre domaine métier (tweets, utilisateurs, messages, likes etc.). Cette couche est la plus profonde, et se situe au cœur de notre application. Elle est indépendante des implémentations techniques réalisées dans les couches supérieures, et peut être utilisée par ces derniers. En parlant d’entité, on fait référence à la donnée stockée en base de données.</li><li>La couche “<b>Cas d’usage</b>” représente les actions que l’utilisateur veut effectuer, et les règles métiers qui l’encadrent. Par exemple, notre utilisateur souhaite visualiser tous les tweets qu’il a postés. Pour procéder, on va écrire un cas d’usage pour cette action spécifique. Cette couche va interagir avec la couche “entité” pour récupérer la liste des tweets voulus.</li><li>La couche \"<b>controleur</b>\" fait le lien entre les couches externes et la couche “cas d’usage”. Elle adapte les données envoyées par la couche d’usage au format nécessaire et les présente à l’interface utilisateur.</li><li>Enfin, la couche <b>externe</b> comprend tout ce qui est en contact avec le monde extérieur, comme l’interface utilisateur, les systèmes de bases de données, les serveurs web, etc. Cette couche est tenue à l’écart des règles métier et sert uniquement à communiquer avec d’autres systèmes ou avec l’utilisateur.</li></ol>Pour prendre un exemple concret de notre application, lorsqu’un utilisateur souhaite récupérer les tweets qu’il a écrit, il émet une requête au backend sur <b>GET /my-tweets</b>.\nLe backend fait appel au code présent dans la couche controleur.</p><div class='blog-img-wrapper'><img class='blog-img' src='/img/couche-controleur.png'/><i>Exemple de cas d'usage au sein de la couche controleur (liste exhaustive)</i></div><p>La couche controleur va alors appeler la couche cas d’usage.\nLa couche cas d’usage va requêter la base de données (couche entité) pour obtenir la liste des tweets et retourne cette liste à la couche controleur.</p><div class='blog-img-wrapper'><img class='blog-img' src='/img/cas-dusage.png'/><i>Un exemple de cas d’usage dans cette couche, ici “récupérer les tweets likés par l’utilisateur (fonction findLikedTweetsByUser)”</i></div><p>La couche controleur adapte le format de la réponse qu’il a eu de la part de la couche d’usage, pour envoyer seulement les informations qui intéressent l’utilisateur, et retourne cette réponse formaté à l'utilisateur. J’ai également pris l’initiative de mettre en place des DTO. Les DTO (Data Transfer Model) servent à sérialiser les objets retournée par la base de données, en objet mémoire créé par notre backend. Ils permettent aussi de décrire la structure des entités présentes en base de données. Par exemple, en base de données, la table Tweet contient les propriétés suivantes : <ul><li>content</li><li>date</li><li>dislikes</li><li>likes</li><li>mentionnedPeople</li><li>replies</li><li>retweets</li><li>shares</li><li>uid</li><li>userId</li></ul>On décrirait cette table en déclarant une interface comme telle :</p><div class='blog-img-wrapper'><img class='blog-img' src='/img/dto-exemple.png'/></div><p>De ce fait, pour chaque entité présente dans notre base de données, on peut faire un mapping entre notre backend et cette base de données. Les DTO fournissent de nombreux avantages comme le fait qu’ils nous permettent de décrire en clair la structure de ces entités. De ce fait on écrit du code plus clair et le développeur qui reviendrait dans le projet après 1 mois d’inactivité, n’aura pas besoin d’aller consulter la structure des données présentes en base de données, car il peut consulter directement les DTO. \n\nEn implémentant cette fameuse <b>architecture Clean</b>, j’arrive à maintenir du code dont chaque module est isolé et a une unique responsabilité. Les modules internes peuvent dépendre des modules externes, mais pas inversement.</p><p> De ce fait, si un bug se produit dans mon application, il sera plus facile de le débugger et de le solutionner. Néanmoins, je tiens à préciser que l’<b>architecture Clean</b> n’est en aucun cas un modèle à suivre absolument dans tous les projets. Tout dépend de la complexité de votre application. De plus, il faut prendre cette décision de l'implémenter (partiellement ou complètement) ou non en fonction de vos besoins. Si vous déterminez à l’avance que votre application pourrait grandir en complexité de façon exponentielle alors ça peut être une bonne idée de partir sur une telle architecture, mais pas une obligation. N’oublions pas que parfois, trop architecturer peut rendre le code trop complexe pour ce que ça devrait être. Tout comme ne pas assez architecturer, peut rendre notre application difficile maintenable sur le long terme.\n</p><h2>Conclusion</h2><p>Twitteche a été bien plus qu'un simple clone de Twitter ; c'était une aventure technique passionnante et éducative. La combinaison de technologies modernes, la mise en œuvre de la <b><b>Clean architecture</b></b> et l'intégration de <b><b>TypeScript</b></b> ont contribué à la réussite de ce projet. C'est une réalisation dont je suis fier, témoignant de ma passion pour le développement web et de mes compétences en tant que développeur solitaire à mes temps perdus.</p><p>Le code source de ce projet est disponible sur <a href='https://github.com/rathesh77/twitter-clone-backend'>https://github.com/rathesh77/twitter-clone-backend</a> (backend) et <a href='https://github.com/rathesh77/twitter-clone'>https://github.com/rathesh77/twitter-clone</a> (frontend), deux repo github public qui peuvent être forkés et utilisés par n’importe qui.</p>",
                      "customCss": {}
                  }
              ]
          },
          {
              "banner": {
                  "headline": "lorem ipsum dolor amet",
                  "image": {
                      "src": "/img/pcr.jpg",
                      "alt": ""
                  }
              },
              "title": "Développement en entreprise d’une plateforme administrative pour centre de dépistage PCR",
              "customCss": {},
              "direction": "row",
              "elements": [
                  {
                      "type": "text",
                      "sort": 2,
                      "content": "<p>En pleine période de Covid, les administrations pharmaceutiques ont besoin de saisir les formulaires des personnes se faisant dépister du covid - 19 via tests PCR. Certaines d’entre elles ne peuvent pas gérer manuellement les entrées administratives en raison d’une augmentation conséquente des personnes malades. Pour cela, le laboratoire Clément a sollicité l’entreprise afin d’avoir en sa possession un outil en ligne pouvant simplifier l’entrée des formulaires.</p><p>Cet outil consiste en une plateforme en ligne permettant d’entrer les informations via un formulaire PCR généré automatiquement par la plateforme. Normalement, le patient remplissait un fichier PDF, puis l’envoyait au centre de dépistage. Ensuite, le centre de dépistage rentrait les informations manuellement dans leur logiciel nommé « Concerto ». L’objectif est d’enlever cette dernière étape en permettant au patient d’entrer directement son formulaire sur une plateforme qui sera développé par notre entreprise. Le formulaire enregistré sur notre plateforme, sera transmis automatiquement au centre de dépistage, dans « Concerto ».<p>L’arrivé d’un nouveau client présente un enjeu financier et de visibilité pour l’entreprise. Un tel projet peut engranger une grosse entrée d’argent dans l’entreprise, d’autant plus « grâce » à la période de crise du Covid - 19 qui génère une grande demande sur le marché pharmaceutique. De plus, ce projet pourrait donner une certaine visibilité à XO7, pouvant attirer davantage de clients provenant de tous secteurs confondus. J’ai eu l’opportunité de participer au développement de la plateforme en ligne permettant de lister les formulaires saisis, à la mise en place du formulaire destiné au patient (ce dernier étant généré après que le patient ait scanné un QR code) ainsi que la transmission de ce dernier vers « Concerto » du laboratoire concerné.</p><p>Dans le cadre de ce projet, j’ai collaboré avec une petite équipe de développeurs frontend et backend et avec une cheffe de projet interne à notre entreprise, qui gérait la communication et le recueil des besoins auprès du directeur des laboratoires Clément.<h2>Ma contribution au sein du projet</h2><p>J'ai eu l'occasion de mettre en place le formulaire de saisie des données destiné aux patients. J'ai egalement mis en place le backoffice destiné aux administrateurs qui doivent pouvoir avoir accès aux fiches remplis par les patients. Enfin, j'ai mis en place la communication API entre le backoffice et Concerto pour l'envoi des formulaires ordonné manuellement par un administrateur, vers Concerto. De ce fait, une fois que l'administrateur constate la bonne validité des informations saisies par un patient, il peut appuyer sur un simple bouton pour télétransmettre ses informations vers Concerto.</p>A l’issue de ce projet, les laboratoires Clément ont gagné en efficacité grâce à notre système, car désormais, ils n’ont plus besoin d’entrer les formulaires PCR manuellement.</p><h2>Bilan du projet</h2><p>Ce projet a pu m’apporter une nouvelle expérience, de nouvelles connaissances techniques et une montée en compétences. Cependant, ce projet comportait des risques : <ul><li>L’entreprise pourrait ne pas tenir les délais de livraison</li><li>Le client pourrait trouver un prestataire remplaçant</li><li>Les pannes sur la plateforme en cours de développement, pourraient causer des problèmes administratifs et mécontenter les clients de la plateforme</li></ul>Depuis la fin de la crise sanitaire, en raison de la baisse du nombre de cas lié à la COVID - 19, la demande a chuté, ce qui laisse notre projet dans un état « inactif ».</p><p>Cette réalisation m’a aidé à progresser dans le sens où j’ai développé une capacité à m’adapter face à différents clients et comprendre les enjeux et besoins du projet.</p>",
                      "customCss": {}
                  }
              ]
          },
          {
              "banner": {
                  "headline": "lorem ipsum dolor amet",
                  "image": {
                      "src": "/img/compiler.png",
                      "alt": ""
                  }
              },
              "title": "Développement d'un compilateur source à source",
              "customCss": {},
              "direction": "row",
              "elements": [
                  {
                      "type": "text",
                      "sort": 3,
                      "content": "Durant mon cursus de développeur à L’ESIEA, j’ai eu l’occasion de développer un compilateur “Code maison” vers le langage Javascript. Pour ma part, je suis un grand passionné par l'étude des algorithmes ainsi que l’utilisation de diverses structures de données. Ainsi, ce projet m’a permis de comprendre et utiliser les arbres syntaxiques, qu’on verra plus en détail ci-dessous.\t<h1>Qu’est-ce qu’un compilateur  source à source</h1><p>Un compilateur source à source est un programme qui va convertir un programme écrit dans un langage A, vers un langage B. L’exemple le plus connu aujourd’hui étant Babel JS, un compilateur qui sait convertir du code Javascript d’une certaine version vers un code Javascript d’une version antérieure, permettant d’assurer la rétrocompatibilité sur des moteurs javascript plus anciens. Un compilateur suit des étapes précises.</p>\t<h2>L’analyse lexicale</h2><p>Pour chaque instruction, le compilateur identifie chaque <b>lexème</b> (mot) de l’instruction. exemple : <div class='blog-img-wrapper'><img class='blog-img' src='/img/ex_langage_naturel.jpg'></div> Ci-dessus, on identifie chaque <b>lexème</b> (mot) de la phrase “Pierre aime-t-il ( un peu ) les pommes ?” en leur attribuant une nature (une classification, ex : adverbe).</p>\t<h2>L’analyse syntaxique</h2>\t<p>L’analyse syntaxique se base sur la forme des instructions. Autrement dit, il faut que chaque <b>lexème</b> présent dans chaque instruction soit placé dans un ordre qui lui donne du sens. En reprenant l’exemple de la phrase “Pierre aime-t-il ( un peu ) les pommes ?”,  ça ne ferait pas sens si on plaçait un autre <b>lexème</b> que “Pierre” en début de phrase (sans rajouter de majuscule pour compenser l’incohérence, on inverse seulement l’ordre de deux mots), comme “aime” par exemple, car toute phrase commence par une majuscule et se termine par un point, ce qui donnerait “aime Pierre -t-il (un peu) les pommes ?”...</p>\t<h2>L’analyse sémantique</h2><p>L’analyse sémantique est complémentaire à l’analyse syntaxique, et se base elle sur le fond des instructions. Dans cette étape, on vérifie si les <b>lexèmes</b> ont un sens dans leur contexte. Pour prendre un exemple réel, dans notre code maison, on aura affaire à des déclarations de variables. Les variables peuvent avoir plusieurs types (entier, chaîne de caractères, booléens etc.). <p>L’expression <b>“entier A = 5”</b> fait sens car on déclare une variable “A” de type entier, et on lui stock la valeur 5, qui est bien un entier.</p><p>L’expression <b>“entier A = 5+9-2”</b> est également bonne, car on fait une opération d’addition ainsi qu’une opération de soustractions sur des entiers, et seulement des entiers.</p>Cependant, l’instruction <b>“entier A = bonjour’”</b> est sémantiquement incorrecte, bien qu’elle soit syntaxiquement correcte. En effet, on déclare une variable de type entier, mais on lui affecte une chaîne de caractère. Il y a ici incohérence des types et donc erreur ! <p>Autre exemple, l’instruction <b>“entier A = 5 + ‘bonjour’”</b> est sémantiquement incorrecte car on additionne un entier à une chaîne de caractère, qu’on stocke ensuite dans une variable de type entier.</p><p>Pour prendre un exemple un peu plus compliqué, l’instruction: <b>“chaine A = 5 + ‘bonjour’”</b> pourrait être jugé comme fausse par notre compilateur, bien que ce genre d’instruction est toléré dans beaucoup de langage de programmation aujourd’hui, car ici, on additionne un entier à une chaine de caractere et on l’assigne à une variable de type “chaine”. Dans la majorité des langages de programmation existants, on appelle celà de la concaténation de chaines de caracteres, c’est-à-dire qu’on vient ajouter au début de  la chaine de caractère “bonjour”, l’entier 5, qui se retrouve automatiquement “converti” en caractère par le compilateur. Notre variable “A” contiendra donc la chaine de caractère “5bonjour”, ce qui est valide sémantiquement parlant.</p><p>Pour finir, on va revenir sur l’exemple de la phrase concernant Pierre. En plein milieu de la phrase “Pierre aime t-il (un peu) les pommes”, nous pouvons constater un groupe de mots “(un peu)” très suspicieux. En effet, syntaxiquement il n y a pas de problème à insérer une parenthèse ouvrante et fermante ainsi que plusieurs mots entre ces parenthèses. Néanmoins, on comprend rapidement que sémantiquement parlant il y a un problème car cela ne fait pas sens de dire “(un peu)” en plein milieu de cette phrase particulièrement. Il faut bien distinguer syntaxe et sémantique. Dans la sémantique, on s'intéresse vraiment au sens profond de chaque <b>lexème</b> par rapport aux autres <b>lexèmes</b> tandis que dans la syntaxe on observe simplement l'ordre des <b>lexèmes</b> et la grammaire.</p>\t<h1>Quelques fonctionnalités développées</h1><p>Un programme est un ensemble d’instructions destinées à être exécutées une par une par le processeur. Dans les langages de programmation, chaque instruction a une syntaxe spécifique. Voilà quelques exemples dans le langage Javascript: <li>pour déclarer une variable “A” contenant la valeur 45: <b>let A = 45</b></li><li>Pour effectuer une addition et stocker son résultat dans une variable “B”: <b>let B = 5 + 9</b></li><li>ecrire une condition si, sinonsi, sinon: <b>if (a == b){ … } else if {} else {}</b></li><li>Ecrire une boucle itérative: <b>for (let i = 0; i &#60; 10; i++) {...}</b></li> <br>Bien évidemment, pour développer un compilateur il faut bien fixer des règles syntaxiques précises, chose que j’ai faite avant de commencer le travail. On verra rapidement les règles que j’ai fixées pour mon “code maison”. Sans trop tarder, voici quelques fonctionnalités prises en compte pour ce compilateur : <h3>Analyse lexicale/syntaxique :</h3><li>opérateurs binaire</li> <li>appel de fonction</li><li>opérateur binaire (+, -, &#62;=, &#62;, &#60;, &#60;=, ==, *, \/, ET, OU)</li><li>définition de fonction (fonction mafonction (entier a) : entier { } )</li><li>déclaration de variable / initialisation (entier a; entier b = 1;)</li><li>affectation (b = 2)</li><li>branchement (si / sinon si / sinon)</li><li>boucle (tantque () { })</li><li>retourner</li><li>variable de type entier SEULEMENT</li> <h3>Analyse sémantique :</h3><li>Vérification des variables (declaration/redeclaration) dans les boucles, conditions, fonctions et appels de fonctions.</li><li>Vérification des fonctions (declaration/appel)</li></p><h1>Technologies utilisées</h1></h2><p>J’ai développé ce compilateur en langage C, langage bas niveau privilégié pour ses  bonnes performances, notamment dans les projets d'électronique embarqué. Pour compiler le code écrit en C, j’ai utilisé le compilateur bien connu “GCC”. De plus, j'ai utilisé l’outil populaire “Make” qui permet de produire des exécutables à partir de fichiers source. Cet outil est très pratique lorsque notre programme comporte de nombreux fichiers source. Dans ce cas, sans Make, on devrait écrire en entier une longue ligne de commande pour compiler chaque fichier. C’est là que Make intervient car on a juste à lui fournir des règles, chaque règle étant associée à une ligne de commande. De ce fait, en moins de 10 secondes, on peut compiler un logiciel et le rendre exécutable.</p>\t<h1>Les arbres syntaxique</h1><p>On en vient au fameux sujet qui m’a motivé à mener à terme ce projet jusqu’au bout : les arbres syntaxiques. Comment notre compilateur va t-il procéder pour convertir du code maison en javascript ? L’idée globale est que le compilateur parcourt de haut en bas chaque ligne de code. On appelle ce procédé le “Parsing”. Durant tout le processus de parsing, il va alors construire une liste chainée, et pour chaque ligne de code, il va créer un “noeud”. Un nœud comporte une racine, et des feuilles. La racine représente la nature de notre expression (ligne de code pour faire plus simple) tandis que les feuilles vont décrire en détail l’expression. <div class='blog-img-wrapper'><img class='blog-img' src='/img/noeud_ast.jpg'><i>un noeud de notre arbre</i></div></br>Par exemple, ci-dessus vous avez un nœud décrivant une opération, plus précisément une addition. En partant de la gauche vers la droite, on lit “5+4”. Au fur et à mesure qu’on va parser le code maison, on construit un nœud pour chaque instruction. A la fin on se retrouve avec un arbre complet. Une fois cet arbre complet, on a juste à le parser (parcourir) de haut en bas pour ainsi générer le code Javascript. A noter que durant cette étape, on est à l'étape de l’analyse lexicale + syntaxique. En effet, on effectue l’analyse lexicale ET syntaxique en simultané pour chaque instruction. Une fois toute cette étape terminée et notre arbre syntaxique entièrement généré, on peut passer à l’analyse sémantique. Dans l’analyse sémantique d’un langage de programmation, et dans le cadre de mon projet, on va seulement vérifier la cohérence des types (comme évoqué plus loin au-dessus).</p> <h1>Génération du code Javascript</h1><p>Félicitations, nous avons notre arbre syntaxique qui a été analysé syntaxiquement et sémantiquement. A présent on peut générer le code javascript. Cette étape est la plus simple et la plus rapide. On parcourt notre arbre et pour chaque nœud dans l’arbre, on génère le code javascript suivant. <div class='blog-img-wrapper'><img class='blog-img' src='/img/ex_ast.jpg'><i>Exemple d’un arbre syntaxique généré depuis un code maison, qui sera utilisé pour générer du code assembleur bas niveau</i></div></br>Le code source de ce projet est disponible à l’adresse <a href='https://github.com/rathesh77/CCompiler'>https://github.com/rathesh77/CCompiler</a> sur un repo github public qui peut être forké et utilisé par n’importe qui.</p>",
                      "customCss": {}
                  }
              ]
          }
      ]
  }
}